<!DOCTYPE html>
<html>
<style>
	body{
		overflow: hidden;
	}
	@keyframes change_border_opacity{
		from{
			border:2.5px solid rgba(0,0,0,0.15)
		}
		to{
			border:2.5px solid rgba(0,0,0,1)
		}
	}
	@keyframes change_opacity{
		from{
			opacity: 0.15;
		}
		to{
			opacity: 1;
		}
	}
	@keyframes reverse_opacity{
		from{
			opacity: 1;
		}to{
			opacity: 0.15;
		}
	}
	@keyframes reverse_border_opacity{
		from{
			border:2.5px solid rgba(0,0,0,1)
		}
		to{
			border:2.5px solid rgba(0,0,0,0.15);
		}
	}
	
html, body {
    width: 100%;
}
table{
	border-collapse: collapse;
  padding: 0;
  border-spacing: 5px;
 
  padding:5px;


}

tr{
	padding:5px;
}

.border_opacity_animation{
	animation-name:change_border_opacity;
	animation-duration: 0.1s;
}
.border_opacity_animation_reverse{
	animation-name:reverse_border_opacity;
	animation-duration: 0.1s;
}
.opacity_animation{
	animation-name:change_opacity;
	animation-duration:0.1s;
}
.opacity_animation_reverse{
	animation-name:reverse_opacity;
	animation-duration:0.1s;
}

th{
	border:2.5px solid rgba(0,0,0,0.15);
}
.rect{
	 width:20px;
  height:20px;
  padding:auto;

}
.parent{
	  text-align:center;
}
.center{
  display: flex;
  align-content: center;
  justify-items: center;
}

th div{
	background-color:#000;
	opacity:0.15;
}
.full_size{
	width:100%;
	height:100%;
}
.center{
	display:flex;
	align-content: center;
	justify-items: center;
}
.filler{
	background:black;
	width:16px; 
	height:16px;
	padding:0px;
	margin:auto;
}

div{
	border-collapse: collapse;
}
#outer_layer{
	border:4px black solid;
	width: max-content;
	margin:auto auto;
	padding:5px;
}
#shape_preview{
	position: fixed;
	right:425px;
	top:10%;
	border:2px black solid;
	width:125px;
	height:350px;


}
.relative_pos{
	position: relative;
	height:max-content;
}
.selected{
border:2.5px solid rgba(0,0,0,1);
background-color:red;
}
.selected > *{
	opacity: 1;
}
</style>
<body>
<div is="rect-container">
</div>
<div is="shape-one" >
</div>

<div id='outer_layer'>
<table id='main_table'> 

</table>
</div>


<div id='shape_preview'>
	<div class='relative_pos'></div>
</div>
<button> Start</button>
<script> 
	let interval;
	let current_position = {
		x:0,
		y:0
	}
	let current_shape_list = [];
function retrieve_dimension(name) {
  let div = document.createElement('div');
  div.id = name;
  document.body.appendChild(div);
  let dim = div.getBoundingClientRect();
  div.remove();
  return {
    height: dim.height,
    width: dim.width
  };
}

const table = document.querySelector('#main_table');
let raw_num = 24;
let col_num = 12;
const rects_list = [];
for (let j = 0; j < raw_num; j++) {
  let tr = document.createElement('tr');
  const sub_list = [];
  for (let i = 0; i < col_num; i++) {
    let th = document.createElement('th');

    th.className = "parent rect";
    th.innerHTML = `<div class='filler opacity_animation'></div>`
    tr.appendChild(th);
    sub_list.push(th);
  }
  rects_list.push(sub_list);
  table.appendChild(tr);
}

function apply_animation() {
  table.querySelectorAll("th").forEach((th, num) => {
    th.querySelector("div").classList.add("opacity_animation");
    th.classList.add("border_opacity_animation");
    th.style.animationDelay = `${Math.floor(num/col_num)/20}s`;
    th.addEventListener("animationend", function() {
      th.style.borderColor = "rgba(0,0,0,1)";
      if (num === raw_num * col_num - 1) {
        Array.from(table.querySelectorAll("th")).reverse().forEach((th, num) => {
          th.classList.add("border_opacity_animation_reverse");
          th.style.animationDelay = `${Math.floor(num/col_num)/20}s`;
          th.addEventListener("animationend", event => {
            th.style.borderColor = "rgba(0,0,0,0.15)"
          })

        })
      }
    })

    th.querySelector("div").style.animationDelay = `${Math.floor(num/col_num)/20}s`;
    th.querySelector("div").addEventListener("animationend", event => {

      event.target.style.opacity = 1;

      if (num === raw_num * col_num - 1) {
        Array.from(table.querySelectorAll("th")).reverse().forEach((th, num) => {
          th.querySelector("div").classList.add("opacity_animation_reverse");
          th.querySelector("div").style.animationDelay = `${Math.floor(num/col_num)/20}s`;
          th.querySelector("div").addEventListener("animationend", event => th.querySelector("div").style.opacity = 0.15);


        })
      }

    })
  })

}
apply_animation();

const parent_container = document.querySelector("#shape_preview");

function shape_1(sequence) {
  const list = create_basic_shape("shape_one")
  const dimension = list[0].getBoundingClientRect();
  const starting_left_value = initial_position(sequence, dimension, 3, 2).x;
  const starting_top_value = initial_position(sequence, dimension, 3, 2).y;
  list[0].style.left = `${starting_left_value}px`;
  list[0].style.top = `${starting_top_value}px`


  const border_size = parseFloat(window.getComputedStyle(list[0]).getPropertyValue("border-width"));
  list[1].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[1].style.top = `${starting_top_value}px`;
  list[2].style.left = `${ starting_left_value + dimension.width*2 - border_size*2}px`;
  list[2].style.top = `${starting_top_value}px`;
  list[3].style.left = `${starting_left_value}px`;
  list[3].style.top = `${starting_top_value + dimension.height - border_size}px`;
  list[0].parentNode.setAttribute("max_x", 3);
  list[0].parentNode.setAttribute("max_y", 2);
     list[0].parentNode.setAttribute("number_of_rects", 4);
  list[0].parentNode.setAttribute("value_skip", JSON.stringify([
    [1, 1],
    [1, 2]
  ]));



}

function initial_position(level, dimension, max_x, max_y) {

  return {
    x: (parseFloat(parent_container.getBoundingClientRect().width) - max_x * dimension.width) / 2,
    y: (parseFloat(parent_container.getBoundingClientRect().height) * level / 5 + (parseFloat(parent_container.getBoundingClientRect().height) / 5 - max_y * dimension.height) / 2)
  }
}

function create_basic_shape(id) {
  let div = document.createElement('div');
  div.id = id;
  div.className = 'shape_container';
  const list = [];
  for (let i = 0; i < 4; i++) {
    let rect = document.createElement('div');
    rect.className = 'rect center';
    rect.style.border = '2.5px black solid';
    rect.innerHTML = `<div class='filler'></div>`
    div.appendChild(rect);
    list.push(rect);
    rect.style.position = 'absolute';
  }
  parent_container.querySelector(".relative_pos").appendChild(div);

  return list;
}

function shape_2(sequence) {
  const list = create_basic_shape("shape_two");
  const dimension = list[0].getBoundingClientRect();
  const starting_left_value = initial_position(sequence, dimension, 2, 2).x;
  const starting_top_value = initial_position(sequence, dimension, 2, 2).y;
  list[0].style.left = `${starting_left_value}px`;
  list[0].style.top = `${starting_top_value}px`

  const border_size = parseFloat(window.getComputedStyle(list[0]).getPropertyValue("border-width"));
  list[1].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[1].style.top = `${starting_top_value}px`;
  list[2].style.left = `${starting_left_value}px`;
  list[2].style.top = `${starting_top_value + dimension.height - border_size}px`;
  list[3].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[3].style.top = `${starting_top_value + dimension.height - border_size}px`;
  list[0].parentNode.setAttribute("max_x", 2);
  list[0].parentNode.setAttribute("max_y", 2);
     list[0].parentNode.setAttribute("number_of_rects", 4);
  list[0].parentNode.setAttribute("value_skip", JSON.stringify([]));


}

function shape_3(sequence) {
  const list = create_basic_shape("shape_three")
  const dimension = list[0].getBoundingClientRect();
  const starting_left_value = initial_position(sequence, dimension, 3, 2).x;
  const starting_top_value = initial_position(sequence, dimension, 3, 2).y;
  list[0].style.left = `${starting_left_value}px`;
  list[0].style.top = `${starting_top_value}px`


  const border_size = parseFloat(window.getComputedStyle(list[0]).getPropertyValue("border-width"));
  list[1].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[1].style.top = `${starting_top_value}px`;
  list[2].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[2].style.top = `${starting_top_value + dimension.height - border_size}px`;
  list[3].style.left = `${starting_left_value + 2*dimension.width - border_size * 2}px`;
  list[3].style.top = `${starting_top_value + dimension.height - border_size}px`;
  list[0].parentNode.setAttribute("max_x", 3);
  list[0].parentNode.setAttribute("max_y", 2);
     list[0].parentNode.setAttribute("number_of_rects", 4);
  list[0].parentNode.setAttribute("value_skip", JSON.stringify([
    [0, 2],
    [1, 0]
  ]));

}


function shape_4(sequence) {
  const list = create_basic_shape("shape_four")
  const dimension = list[0].getBoundingClientRect();
  const starting_left_value = initial_position(sequence, dimension, 4, 1).x;
  const starting_top_value = initial_position(sequence, dimension, 4, 1).y;
  list[0].style.left = `${starting_left_value}px`;
  list[0].style.top = `${starting_top_value}px`;
  const border_size = parseFloat(window.getComputedStyle(list[0]).getPropertyValue("border-width"));
  list[1].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[1].style.top = `${starting_top_value}px`;
  list[2].style.left = `${starting_left_value + 2*dimension.width - 2*border_size}px`;
  list[2].style.top = `${starting_top_value}px`;
  list[3].style.left = `${starting_left_value + 3*dimension.width - border_size * 3}px`;
  list[3].style.top = `${starting_top_value}px`;
  list[0].parentNode.setAttribute("max_x", 4);
  list[0].parentNode.setAttribute("max_y", 1);
     list[0].parentNode.setAttribute("number_of_rects", 4);
  list[0].parentNode.setAttribute("value_skip", JSON.stringify([]));

}

function shape_5(sequence) {
  const list = create_basic_shape("shape_five")
  const dimension = list[0].getBoundingClientRect();
  const starting_left_value = initial_position(sequence, dimension, 3, 2).x;
  const starting_top_value = initial_position(sequence, dimension, 3, 2).y;
  const border_size = parseFloat(window.getComputedStyle(list[0]).getPropertyValue("border-width"));
  list[0].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[0].style.top = `${starting_top_value}px`
  list[1].style.left = `${starting_left_value}px`;
  list[1].style.top = `${starting_top_value + dimension.height - border_size }px`;
  list[2].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[2].style.top = `${starting_top_value + dimension.height - border_size}px`;
  list[3].style.left = `${starting_left_value + 2*dimension.width - border_size * 2}px`;
  list[3].style.top = `${starting_top_value + dimension.height - border_size}px`;
  list[0].parentNode.setAttribute("max_x", 3);
  list[0].parentNode.setAttribute("max_y", 2);
   list[0].parentNode.setAttribute("number_of_rects", 4);
  list[0].parentNode.setAttribute("value_skip", JSON.stringify([
    [0, 0],
    [0, 2]
  ]));
}

function shape_6(sequence) {
  const list = create_basic_shape("shape_six")
  const dimension = list[0].getBoundingClientRect();
  const starting_left_value = initial_position(sequence, dimension, 3, 2).x;
  const starting_top_value = initial_position(sequence, dimension, 3, 2).y;
  const border_size = parseFloat(window.getComputedStyle(list[0]).getPropertyValue("border-width"));
  list[0].style.left = `${starting_left_value }px`;
  list[0].style.top = `${starting_top_value}px`
  list[1].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[1].style.top = `${starting_top_value }px`;
  list[2].style.left = `${starting_left_value + 2*dimension.width - 2*border_size}px`;
  list[2].style.top = `${starting_top_value }px`;
  list[3].style.left = `${starting_left_value + 2*dimension.width - 2*border_size}px`;
  list[3].style.top = `${starting_top_value + dimension.height - border_size}px`;
  list[0].parentNode.setAttribute("max_x", 3);
  list[0].parentNode.setAttribute("max_y", 2);
     list[0].parentNode.setAttribute("number_of_rects", 4);
  list[0].parentNode.setAttribute("value_skip", JSON.stringify([
    [1, 0],
    [1, 1]
  ]));
}

function shape_7(sequence) {
  const list = create_basic_shape("shape_seven")
  const dimension = list[0].getBoundingClientRect();
  const starting_left_value = initial_position(sequence, dimension, 3, 2).x;
  const starting_top_value = initial_position(sequence, dimension, 3, 2).y;
  const border_size = parseFloat(window.getComputedStyle(list[0]).getPropertyValue("border-width"));
  list[0].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[0].style.top = `${starting_top_value}px`
  list[1].style.left = `${starting_left_value}px`;
  list[1].style.top = `${starting_top_value + dimension.height - border_size }px`;
  list[2].style.left = `${starting_left_value + dimension.width - border_size}px`;
  list[2].style.top = `${starting_top_value + dimension.height - border_size}px`;
  list[3].style.left = `${starting_left_value + 2*dimension.width - border_size * 2}px`;
  list[3].style.top = `${starting_top_value}px`;
  list[0].parentNode.setAttribute("max_x", 3);
  list[0].parentNode.setAttribute("max_y", 2);  
   list[0].parentNode.setAttribute("number_of_rects", 4);
  list[0].parentNode.setAttribute("value_skip", JSON.stringify([
    [0, 0],
    [1, 2]
  ]));
}

function interval_function(){
	 let has_ended = false;
	 const current_shape = document.querySelectorAll('.shape_container')[0];


    let new_position_list = [];
    let initial_row = maximum_row(current_position_x);
      	let max_y = parseFloat(current_shape.getAttribute("max_y"));
        for (let i = 0; i < parseFloat(current_shape.getAttribute("max_y")); i++) {
        	
          for (let j = 0; j < parseFloat(current_shape.getAttribute("max_x")); j++) {
            if (!JSON.parse(current_shape.getAttribute("value_skip")).some((arr, num) => arr[0] === i && arr[1] === j) ) new_position_list.push([initial_row+i,current_position.x+j]);
        }
    }
   
    new_position_list.forEach(arr => {
      if (new_position_list.) {
        rects_list[arr[0] - 1][arr[1]].classList.add('selected', "locked");
        has_ended = true;
      } else rects_list[arr[0]][arr[1]].classList.add('selected');
    })
    if(has_ended){
    	  window.clearInterval(interval);
            random_shape();
            drop_function();
    }
}
function drop_function() {
  const current_shape = parent_container.querySelectorAll('.shape_container')[0];
  const max_x = current_shape.getAttribute("max_x");
  const max_y = current_shape.getAttribute('max_y');
  const value_skipped = JSON.parse(current_shape.getAttribute('value_skip'))
  const random_pos_x = Math.floor(Math.random() * (col_num - max_x+1));
  current_position.x = random_pos_x;
  for (let i = 0; i < max_y; i++) {
    for (let j = 0; j < max_x; j++) {
      if (!value_skipped.some((arr, num) => arr[0] === i && arr[1] === j)) {
        rects_list[i][random_pos_x + j].classList.add('selected')
      }

    }


  }
  interval = setInterval(interval_function, 500)
}


function random_shape() {
	    document.querySelectorAll('.shape_container').forEach(ele=>ele.remove());
  for (let i = 0; i < 5; i++) {
    let random_num = Math.floor(Math.random() * 7) + 1;
    current_shape_list.push(random_num);
    eval(`shape_${random_num}(${i})`);
  }
}


document.addEventListener("keypress", event => {
  if (event.key == " " || event.code == "Space" || event.keyCode == 32) {

    const current_shape = document.querySelectorAll('.shape_container')[0];
    /*for (let current_index_y = rects_list.length - 1; current_index_y >= 0; current_index_y--) {
      let pass = true;
      for (let current_index_x = rects_list[current_index_y].length - 1; current_index_x >= 0; current_index_x--) {
        if (rects_list[current_index_y][current_index_x].classList.contains('locked')) {
          pass = false;
          break;
        }
      }
      if (pass) {*/
    let initial_row = maximum_row();
      	let max_y = parseFloat(current_shape.getAttribute("max_y"));
        for (let i = 0; i < parseFloat(current_shape.getAttribute("max_y")); i++) {
        	
          for (let j = 0; j < parseFloat(current_shape.getAttribute("max_x")); j++) {
            if (!JSON.parse(current_shape.getAttribute("value_skip")).some((arr, num) => arr[0] === i && arr[1] === j)){
rects_list[initial_row+ i ][current_position.x + j].classList.add('selected',"locked");
            } 
          
        }
      
    }

    document.querySelectorAll('.selected:not(.locked)').forEach(ele=>ele.classList.remove('selected'));
    window.clearInterval(interval);
    document.querySelectorAll('.shape_container').forEach(ele=>ele.remove());

    let random_num = Math.floor(Math.random() * 7) + 1;
    current_shape_list.shift();
    current_shape_list.push(random_num);
    for (let i = 0; i < 5; i++) eval(`shape_${current_shape_list[i]}(${i})`);
    drop_function();

  }
});

random_shape();


drop_function();


function maximum_row(){
  const max_x =parseFloat(document.querySelector('.shape_container').getAttribute("max_x"));
  const max_y = parseFloat(document.querySelector('.shape_container').getAttribute('max_y'));
  const value_skip = JSON.parse(document.querySelector('.shape_container').getAttribute('value_skip'));
	for(let i=0; i<raw_num-max_y+1;i++){
		for(let y =0; y<max_y;y++){
			for(let j =0; j< max_x;j++){
				if(rects_list[i + y][current_position.x + j].classList.contains("locked")&&!value_skip.some((arr, num) => arr[0] === y && arr[1] === j)) 
					return i-1;
		}
		}
	
	}
			return raw_num-max_y;
}


</script>
</body>

</html>
