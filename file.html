<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<head>
<link rel="stylesheet" href="tetris.css">


</head>
<body>
<div is="rect-container">
</div>
<div is="shape-one" >
</div>

<div id='outer_layer'>
<table id='main_table'> 

</table>
</div>


<div id='shape_preview'>
	<div class='relative_pos'></div>
</div>
<button> Start</button>
<script  src="const.js"> </script>
<script src='set_up.js'></script>
<script  src="event.js"> </script>
<script>

/*
const parent_container = document.querySelector("#shape_preview");



function initial_position(level, dimension, max_x, max_y) {

  return {
    x: (parseFloat(parent_container.getBoundingClientRect().width) - max_x * dimension.width) / 2,
    y: (parseFloat(parent_container.getBoundingClientRect().height) * level / 5 + (parseFloat(parent_container.getBoundingClientRect().height) / 5 - max_y * dimension.height) / 2)
  }
}

function create_basic_shape(id) {
  let div = document.createElement('div');
  div.id = id;
  div.className = 'shape_container';
  const list = [];
  for (let i = 0; i < 4; i++) {
    let rect = document.createElement('div');
    rect.className = 'rect center';
    rect.style.border = '2.5px black solid';
    rect.innerHTML = `<div class='filler'></div>`
    div.appendChild(rect);
    list.push(rect);
    rect.style.position = 'absolute';
  }
  parent_container.querySelector(".relative_pos").appendChild(div);

  return list;
}


/*
function interval_function(){
	 let has_ended = false;
	 const current_shape = document.querySelectorAll('.shape_container')[0];


    let new_position_list = [];
    let initial_row = maximum_row(current_position_x);
      	let max_y = parseFloat(current_shape.getAttribute("max_y"));
        for (let i = 0; i < parseFloat(current_shape.getAttribute("max_y")); i++) {
        	
          for (let j = 0; j < parseFloat(current_shape.getAttribute("max_x")); j++) {
            if (!JSON.parse(current_shape.getAttribute("value_skip")).some((arr, num) => arr[0] === i && arr[1] === j) ) new_position_list.push([initial_row+i,current_position.x+j]);
        }
    }
   
    new_position_list.forEach(arr => {
      if (new_position_list.length <4) {
        rects_list[arr[0] - 1][arr[1]].classList.add('selected', "locked");
        has_ended = true;
      } else rects_list[arr[0]][arr[1]].classList.add('selected');
    })
    if(has_ended){
    	  window.clearInterval(interval);
            random_shape();
            drop_function();
    }
}

function drop_function() {
  const current_shape = parent_container.querySelectorAll('.shape_container')[0];
  const max_x = current_shape.getAttribute("max_x");
  const max_y = current_shape.getAttribute('max_y');
  const value_skipped = JSON.parse(current_shape.getAttribute('value_skip'))
  const random_pos_x = Math.floor(Math.random() * (col_num - max_x+1));
  current_position.x = random_pos_x;
  for (let i = 0; i < max_y; i++) {
    for (let j = 0; j < max_x; j++) {
      if (!value_skipped.some((arr, num) => arr[0] === i && arr[1] === j)) {
        rects_list[i][random_pos_x + j].classList.add('selected')
      }

    }


  }
  interval = setInterval(interval_function, 500)
}


function random_shape() {
	    document.querySelectorAll('.shape_container').forEach(ele=>ele.remove());
  for (let i = 0; i < 5; i++) {
    let random_num = Math.floor(Math.random() * 7) + 1;
    current_shape_list.push(random_num);
    eval(`shape_${random_num}(${i})`);
  }
}


document.addEventListener("keypress", event => {
  if (event.key == " " || event.code == "Space" || event.keyCode == 32) {

    const current_shape = document.querySelectorAll('.shape_container')[0];
    /*for (let current_index_y = rects_list.length - 1; current_index_y >= 0; current_index_y--) {
      let pass = true;
      for (let current_index_x = rects_list[current_index_y].length - 1; current_index_x >= 0; current_index_x--) {
        if (rects_list[current_index_y][current_index_x].classList.contains('locked')) {
          pass = false;
          break;
        }
      }
      if (pass) {*/
/*
    let initial_row = maximum_row();
      	let max_y = parseFloat(current_shape.getAttribute("max_y"));
        for (let i = 0; i < parseFloat(current_shape.getAttribute("max_y")); i++) {
        	
          for (let j = 0; j < parseFloat(current_shape.getAttribute("max_x")); j++) {
            if (!JSON.parse(current_shape.getAttribute("value_skip")).some((arr, num) => arr[0] === i && arr[1] === j)){
rects_list[initial_row+ i ][current_position.x + j].classList.add('selected',"locked");
            } 
          
        }
      
    }

    document.querySelectorAll('.selected:not(.locked)').forEach(ele=>ele.classList.remove('selected'));
    window.clearInterval(interval);
    document.querySelectorAll('.shape_container').forEach(ele=>ele.remove());

    let random_num = Math.floor(Math.random() * 7) + 1;
    current_shape_list.shift();
    current_shape_list.push(random_num);
    for (let i = 0; i < 5; i++) eval(`shape_${current_shape_list[i]}(${i})`);
    drop_function();

  }
});

random_shape();


drop_function();


function maximum_row(){
  const max_x =parseFloat(document.querySelector('.shape_container').getAttribute("max_x"));
  const max_y = parseFloat(document.querySelector('.shape_container').getAttribute('max_y'));
  const value_skip = JSON.parse(document.querySelector('.shape_container').getAttribute('value_skip'));
	for(let i=0; i<raw_num-max_y+1;i++){
		for(let y =0; y<max_y;y++){
			for(let j =0; j< max_x;j++){
				if(rects_list[i + y][current_position.x + j].classList.contains("locked")&&!value_skip.some((arr, num) => arr[0] === y && arr[1] === j)) 
					return i-1;
		}
		}
	
	}
			return raw_num-max_y;
}
*/
window.onload= function(){
for(let i =0; i<preview_num;i++){
  let block = new Block(block_shape[Math.floor(Math.random() * 6)]);
  //let block = new Block(block_shape[5]);
  block_list.push(block);
  block.display(i);

}
  block_list[0].simulate("selected")
  block_list[0].to_bottom(false);
apply_animation();
interval = setInterval(()=>block_list[0].update(),200)
}

</script>

</body>

</html>
